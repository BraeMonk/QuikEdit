<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Sprite Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    font-family: sans-serif;
    padding: 10px;
    text-align: center;
    background: #1c1c1c;
    color: #fff;
  }
  #controls {
    margin-bottom: 10px;
  }
  #canvas {
    display: grid;
    touch-action: none;
    margin: 10px auto;
    border: 1px solid #555;
  }
  .cell {
    border: 1px solid #333;
    box-sizing: border-box;
  }
  button, select, input {
    margin: 5px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
  }
  #swatches {
    margin-top: 10px;
  }
  .swatch {
    display: inline-block;
    width: 30px;
    height: 30px;
    margin: 2px;
    border: 1px solid #333;
    cursor: pointer;
  }
  .swatch.selected {
    border: 3px solid #fff;
  }
  pre {
    text-align: left;
    max-width: 100%;
    overflow-x: auto;
    background: #222;
    padding: 10px;
    color: #fff;
  }
</style>
</head>
<body>

<h2>Pixel Sprite Editor</h2>

<div id="controls">
  Canvas Size:
  <select id="sizeSelector">
    <option value="8">8x8</option>
    <option value="16" selected>16x16</option>
    <option value="24">24x24</option>
    <option value="32">32x32</option>
    <option value="48">48x48</option>
    <option value="64">64x64</option>
  </select>

  Palette:
  <select id="paletteSelector"></select>

  <button id="undo">Undo</button>
  <button id="redo">Redo</button>
  <button id="clear">Clear</button>
  <button id="export">Export Array</button>
  <input type="file" id="importFile" accept=".json">
</div>

<div id="swatches"></div>
<div id="canvas"></div>
<pre id="output"></pre>

<script>
let colors = [];
let palettes = {};
let array = [];
let canvasSize = 16;
let selectedColor = 0;
let undoStack = [];
let redoStack = [];
const canvas = document.getElementById('canvas');
const sizeSelector = document.getElementById('sizeSelector');
const paletteSelector = document.getElementById('paletteSelector');
let isPainting = false;

// Load palettes.json dynamically
fetch('palettes.json')
  .then(res => res.json())
  .then(data => {
      palettes = data;
      for(let key in palettes){
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key;
        paletteSelector.appendChild(opt);
      }
      paletteSelector.value = Object.keys(palettes)[0];
      colors = palettes[paletteSelector.value];
      initCanvas();
  });

// Handle palette change
paletteSelector.addEventListener('change', () => {
  colors = palettes[paletteSelector.value];
  selectedColor = 0;
  renderSwatches();
  updateCanvasColors();
});

// Handle canvas size change
sizeSelector.addEventListener('change', () => {
  canvasSize = parseInt(sizeSelector.value);
  initCanvas();
});

// Initialize blank canvas
function initCanvas(){
  array = Array.from({length: canvasSize}, () => Array(canvasSize).fill(0));
  undoStack = [];
  redoStack = [];
  renderCanvas();
}

// Render swatches
function renderSwatches() {
  const swatchesDiv = document.getElementById('swatches');
  swatchesDiv.innerHTML = '';
  colors.forEach((color, index) => {
      const swatch = document.createElement('div');
      swatch.className = 'swatch';
      if(index === selectedColor) swatch.classList.add('selected');
      swatch.style.background = color;
      swatch.addEventListener('click', () => {
          selectedColor = index;
          renderSwatches();
      });
      swatchesDiv.appendChild(swatch);
  });
}

function saveState() {
  undoStack.push(array.map(row => row.slice()));
  if(undoStack.length > 50) undoStack.shift();
  redoStack = [];
}

function renderCanvas(){
  canvas.innerHTML = '';
  const cellSize = Math.floor(Math.min(480, window.innerWidth - 20) / canvasSize);
  canvas.style.gridTemplateColumns = `repeat(${canvasSize}, ${cellSize}px)`;
  canvas.style.gridTemplateRows = `repeat(${canvasSize}, ${cellSize}px)`;

  for(let y=0; y<canvasSize; y++){
    for(let x=0; x<canvasSize; x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.dataset.value = array[y][x];
      cell.style.width = `${cellSize}px`;
      cell.style.height = `${cellSize}px`;
      cell.style.background = colors[array[y][x]];

      const paint = () => {
        saveState();
        array[y][x] = selectedColor;
        cell.dataset.value = selectedColor;
        cell.style.background = colors[selectedColor];
      };

      cell.addEventListener('mousedown', (e) => { isPainting=true; paint(); });
      cell.addEventListener('mouseenter', () => { if(isPainting) paint(); });
      cell.addEventListener('mouseup', () => { isPainting=false; });

      cell.addEventListener('touchstart', (e) => { paint(); e.preventDefault(); });
      cell.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if(target && target.classList.contains('cell')) paint.call(target);
        e.preventDefault();
      });

      canvas.appendChild(cell);
    }
  }

  renderSwatches();
  document.body.addEventListener('mouseup', () => isPainting=false);
}

// Update colors when palette changes
function updateCanvasColors(){
  const cells = document.querySelectorAll('.cell');
  cells.forEach(cell => {
    const val = parseInt(cell.dataset.value);
    cell.style.background = colors[val];
  });
}

// Undo & Redo
document.getElementById('undo').addEventListener('click', () => {
  if(undoStack.length){
    redoStack.push(array.map(row => row.slice()));
    array = undoStack.pop().map(row => row.slice());
    renderCanvas();
  }
});

document.getElementById('redo').addEventListener('click', () => {
  if(redoStack.length){
    undoStack.push(array.map(row => row.slice()));
    array = redoStack.pop().map(row => row.slice());
    renderCanvas();
  }
});

// Clear canvas
document.getElementById('clear').addEventListener('click', () => {
  saveState();
  array = Array.from({length: canvasSize}, () => Array(canvasSize).fill(0));
  renderCanvas();
});

// Export array in linear row-by-row fashion
document.getElementById('export').addEventListener('click', () => {
  const linearArray = array.flat();
  document.getElementById('output').textContent = JSON.stringify(linearArray, null, 4);
});

// Import array (auto-resizes canvas)
document.getElementById('importFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const imported = JSON.parse(event.target.result);
      let newArray;
      let newSize;

      if(Array.isArray(imported[0])) {
        // 2D array
        newArray = imported;
        newSize = newArray.length;
      } else {
        // linear array
        newSize = Math.sqrt(imported.length);
        if(!Number.isInteger(newSize)) throw new Error("Invalid linear array length");
        newArray = [];
        for(let i=0; i<imported.length; i+=newSize){
          newArray.push(imported.slice(i,i+newSize));
        }
      }

      saveState();
      canvasSize = newSize;
      sizeSelector.value = canvasSize;
      array = newArray.map(row => row.slice());
      renderCanvas();
    } catch(err) {
      alert('Invalid JSON file.');
      console.error(err);
    }
  };
  reader.readAsText(file);
});
</script>

</body>
</html>
