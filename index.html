<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Sprite Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    font-family: sans-serif;
    padding: 10px;
    text-align: center;
    background: #1c1c1c;
    color: #fff;
  }
  #controls {
    margin-bottom: 10px;
  }
  #canvas {
    display: grid;
    touch-action: none;
    margin: 10px auto;
    border: 1px solid #555;
  }
  .cell {
    border: 1px solid #333;
    box-sizing: border-box;
  }
  button, select {
    margin: 5px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
  }
  pre {
    text-align: left;
    max-width: 100%;
    overflow-x: auto;
    background: #222;
    padding: 10px;
    color: #fff;
  }
</style>
</head>
<body>

<h2>Pixel Sprite Editor</h2>

<div id="controls">
  Canvas Size:
  <select id="sizeSelector">
    <option value="8">8x8</option>
    <option value="16" selected>16x16</option>
    <option value="24">24x24</option>
    <option value="32">32x32</option>
    <option value="48">48x48</option>
    <option value="64">64x64</option>
  </select>

  Palette:
  <select id="paletteSelector"></select>

  <button id="export">Export Array</button>
</div>

<div id="canvas"></div>
<pre id="output"></pre>

<script>
let colors = [];
let palettes = {};
let array = [];
let canvasSize = 16;
const canvas = document.getElementById('canvas');
const sizeSelector = document.getElementById('sizeSelector');
const paletteSelector = document.getElementById('paletteSelector');

let isPainting = false;

// Load palettes.json dynamically
fetch('palettes.json')
  .then(res => res.json())
  .then(data => {
      palettes = data;
      for(let key in palettes){
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key;
        paletteSelector.appendChild(opt);
      }
      paletteSelector.value = Object.keys(palettes)[0];
      colors = palettes[paletteSelector.value];
      initCanvas();
  });

// Handle palette change
paletteSelector.addEventListener('change', () => {
  colors = palettes[paletteSelector.value];
  updateCanvasColors();
});

// Handle canvas size change
sizeSelector.addEventListener('change', () => {
  canvasSize = parseInt(sizeSelector.value);
  initCanvas();
});

// Initialize blank canvas
function initCanvas(){
  array = Array.from({length: canvasSize}, () => Array(canvasSize).fill(0));
  renderCanvas();
}

function renderCanvas(){
  canvas.innerHTML = '';
  const cellSize = Math.floor(Math.min(480, window.innerWidth - 20) / canvasSize);
  canvas.style.gridTemplateColumns = `repeat(${canvasSize}, ${cellSize}px)`;
  canvas.style.gridTemplateRows = `repeat(${canvasSize}, ${cellSize}px)`;

  for(let y=0; y<canvasSize; y++){
    for(let x=0; x<canvasSize; x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.dataset.value = array[y][x];
      cell.style.width = `${cellSize}px`;
      cell.style.height = `${cellSize}px`;
      cell.style.background = colors[array[y][x]];

      const paint = () => {
        let val = parseInt(cell.dataset.value);
        val = (val + 1) % Object.keys(colors).length;
        cell.dataset.value = val;
        array[y][x] = val;
        cell.style.background = colors[val];
      };

      cell.addEventListener('mousedown', (e) => { isPainting=true; paint(); });
      cell.addEventListener('mouseenter', () => { if(isPainting) paint(); });
      cell.addEventListener('mouseup', () => { isPainting=false; });

      cell.addEventListener('touchstart', (e) => { paint(); e.preventDefault(); });
      cell.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if(target && target.classList.contains('cell')) paint.call(target);
        e.preventDefault();
      });

      canvas.appendChild(cell);
    }
  }

  document.body.addEventListener('mouseup', () => isPainting=false);
}

// Update colors when palette changes
function updateCanvasColors(){
  const cells = document.querySelectorAll('.cell');
  cells.forEach(cell => {
    const val = parseInt(cell.dataset.value);
    cell.style.background = colors[val];
  });
}

// Export array to JSON
document.getElementById('export').addEventListener('click', () => {
  document.getElementById('output').textContent = JSON.stringify(array, null, 4);
});
</script>

</body>
</html>
